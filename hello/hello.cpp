#include "llvm/Analysis/ValueTracking.h"
#include "llvm/Analysis/LazyValueInfo.h"
#include "llvm/Pass.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Module.h"
#include "llvm/Support/KnownBits.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Transforms/Utils/Evaluator.h"
#include "llvm/Transforms/Utils/Cloning.h"


#include <string>
#include <unordered_set>

using namespace llvm;

static cl::opt<std::string> LHSName("lhs",
  cl::desc("Name of LHS function to test"),
  cl::value_desc("function"), cl::Required);

namespace {
class RefuteOpts : public llvm::ModulePass {
public:
  static char ID;
  RefuteOpts() : ModulePass(ID) {}


  bool runOnModule(llvm::Module & M) override {

    GenerateLHSConsts(M.getFunction(LHSName)->arg_size(), M);
    llvm::outs () << M.getFunction(LHSName)->arg_size() << "\n";
    for (auto v : LHSConsts) {
      for (auto a : v) {
        a->print(llvm::outs()); llvm::outs () << " ";
      }
      llvm::outs() << "\n";
    }
    TryRefute(M);

    llvm::outs() << "Proved " << refuted.size() << "/" << M.getFunctionList().size() << " functions infeasible.";
  }
private:
  void TryRefute(llvm::Module & M) {
    auto&& LHS = M.getFunction(LHSName);

   // assert(LHS->arg_size() == 1 && "Only supports LHS with one args so far");
    // TODO Get rid of this limitation

    // std::vector<llvm::Constant *> LHSValues;

    for (auto&& v : LHSConsts) {

      llvm::Evaluator eval(M.getDataLayout(), nullptr);

      llvm::Constant *C;
      auto couldEvaluate = eval.EvaluateFunction(LHS, C, v);
      if (!couldEvaluate) {
        llvm::errs() << "Could not evaluate LHS for ";
        for (auto&& x : v) {
          x->print(llvm::errs());
          llvm::errs() << " ";
        }
        llvm::errs() << "\n";
      }


    for (auto&& F : M.getFunctionList()) {

      auto NewF = InstantiateRHS(&F, v, LHS->arg_size());

      if (IsRHSInfeasibleCKB(C, NewF, M)) {
        refuted.insert(&F);
        llvm::outs() << "ckb " << F.getName() << "\n";
      }
      // else if (IsRHSInfeasibleLVI(&F, M)) {
      //   refuted.insert(&F);
      //   llvm::outs() << "lvi " << F->getName() << "\n";
      // }
      else {
        llvm::outs() << "    " << F.getName() << "\n";
      }
      NewF->removeFromParent();
    }


    }



  }

  // bool IsRHSInfeasibleLVI(std::vector<llvm::Constant *> LHSValues,
  //                      llvm::Function *RHS,
  //                      llvm::Module &M) {
  //   if (refuted.find(RHS) != refuted.end()) {
  //     return false;
  //   }

  //   llvm::LazyValueInfo LVI;


  //   return false;

  // }

  llvm::Function *InstantiateRHS
  (llvm::Function *F, const llvm::SmallVector<llvm::Constant *, 2>& args, int num_lhs_args) {
    llvm::ValueToValueMapTy map;
    int j = 0;
    for (auto&& arg : F->args()) {
      if (j == 0) {
        map[&arg] = args[0]; // first i32 arg generated by opt-fuzz
      }
      if (num_lhs_args > 1 && j == 4) {
        map[&arg] = args[1]; // second i32 arg generated by opt-fuzz
      }
      j++;
    }

    return llvm::CloneFunction(F, map);
  }

  bool IsRHSInfeasibleCKB(llvm::Constant *LHS,
                          llvm::Function *RHS,
                          llvm::Module &M) {
    int ConstantIntValue;
    if (ConstantInt* CI = dyn_cast<ConstantInt>(LHS)) {
      if (CI->getBitWidth() <= 32) {
        ConstantIntValue = CI->getSExtValue();
      }
    }
    for (auto &BB : *RHS) {
      for (auto &I : BB) {
        if (I.getOpcode() == Instruction::Ret) {
          KnownBits Known = computeKnownBits(I.getOperand(0), M.getDataLayout());
          if ((Known.Zero & ConstantIntValue) != 0 || (Known.One & ~ConstantIntValue) != 0) {
            return true;
          }
        }
      }
    }
    return false;
  }

  void GenerateLHSConsts(int num_args, llvm::Module &M, int num_sets = 4) {
    std::vector<llvm::Constant *> argstore = {
    llvm::ConstantInt::get(M.getContext(), llvm::APInt(32, 0, false)),
    llvm::ConstantInt::get(M.getContext(), llvm::APInt(32, -1, false)),
    llvm::ConstantInt::get(M.getContext(), llvm::APInt(32, 7479, false)),
    llvm::ConstantInt::get(M.getContext(), llvm::APInt(32, 42, false))};

    llvm::SmallVector<llvm::Constant *, 2> args;

    for (int i = 0; i < num_sets; ++i) {
      args.clear();
      for (int j = 0; j < num_args; ++j) {
        args.push_back(argstore[(4*j + 5*i) % argstore.size()]);
      }
      LHSConsts.push_back(args);
    }
  }

  std::vector<llvm::SmallVector<llvm::Constant *, 2>> LHSConsts;
  std::unordered_set<llvm::Function *> refuted;
};

}  // end of anonymous namespace

char RefuteOpts::ID = 0;
static RegisterPass<RefuteOpts> X("refute", "opt-refute pass",
                             false /* Only looks at CFG */,
                             false /* Analysis Pass */);

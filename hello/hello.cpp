#include "llvm/Analysis/ValueTracking.h"
#include "llvm/Pass.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Module.h"
#include "llvm/Support/KnownBits.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Transforms/Utils/Evaluator.h"
#include "llvm/Transforms/Utils/Cloning.h"


#include <string>
#include <unordered_set>

using namespace llvm;

static cl::opt<std::string> LHSName("lhs",
  cl::desc("Name of LHS function to test"),
  cl::value_desc("function"), cl::Required);

namespace {
class RefuteOpts : public llvm::ModulePass {
public:
  static char ID;
  RefuteOpts() : ModulePass(ID) {}


  bool runOnModule(llvm::Module & M) override {

    GenerateLHSConsts(M.getFunction(LHSName)->arg_size(), M);
    TryRefute(M);

    llvm::outs() << "Proved " << refuted.size() << "/" << M.getFunctionList().size() << " functions infeasible.";
  }
private:
  void TryRefute(llvm::Module & M) {
    auto&& LHS = M.getFunction(LHSName);

    assert(LHS->arg_size() == 1 && "Only supports LHS with one args so far");
    // TODO Get rid of this limitation

    std::vector<llvm::Constant *> LHSValues;

    for (auto&& v : LHSConsts) {

      llvm::Evaluator eval(M.getDataLayout(), nullptr);

      llvm::Constant *C;
      auto couldEvaluate = eval.EvaluateFunction(LHS, C, v);
      if (couldEvaluate) {
        LHSValues.push_back(C);
      } else {
        llvm::errs() << "Could not evaluate LHS for ";
        for (auto&& x : v) {
          x->print(llvm::errs());
          llvm::errs() << " ";
        }
        llvm::errs() << "\n";
      }
    }

    for (auto&& F : M.getFunctionList()) {
      if (IsRHSInfeasible(LHSValues, &F, M)) {
        refuted.insert(&F);
      }
    }

  }

  bool IsRHSInfeasible(std::vector<llvm::Constant *> LHSValues,
                       llvm::Function *RHS,
                       llvm::Module &M) {
    if (refuted.find(RHS) != refuted.end()) {
      return false;
    }

    for (int i = 0; i < LHSValues.size(); ++i) {
      auto LHS = LHSValues[i];
      llvm::ValueToValueMapTy map;
      int j = 0;
      for (auto&& arg : RHS->args()) {
        if (j == 0) {
          map[&arg] = LHSConsts[i][0]; // first i32 arg generated by opt-fuzz
        }
        if (LHSConsts[0].size() > 1 && j == 4) {
          map[&arg] = LHSConsts[i][4]; // second i32 arg generated by opt-fuzz
        }
        j++;
      }

      auto NewF = llvm::CloneFunction(RHS, map);

      int ConstantIntValue;
      if (ConstantInt* CI = dyn_cast<ConstantInt>(LHS)) {
        if (CI->getBitWidth() <= 32) {
          ConstantIntValue = CI->getSExtValue();
        }
      }
      for (auto &BB : *NewF) {
        for (auto &I : BB) {
          if (I.getOpcode() == Instruction::Ret) {
            KnownBits Known = computeKnownBits(I.getOperand(0), M.getDataLayout());
            if ((Known.Zero & ConstantIntValue) != 0 || (Known.One & ~ConstantIntValue) != 0) {
              NewF->removeFromParent();
              llvm::outs() << ":) " << RHS->getName() << "\n";
              return true;
            }
          }
        }
      }
      llvm::outs() << ":( " << RHS->getName() << "\n";
      NewF->removeFromParent();
    }
    return false;
  }

  void GenerateLHSConsts(int num_args, llvm::Module &M) {
    auto&& zero = llvm::ConstantInt::get(M.getContext(), llvm::APInt(32, 0, false));
    llvm::SmallVector<llvm::Constant *, 2> args = {zero, zero};
    LHSConsts.push_back(args);

    auto&& wut = llvm::ConstantInt::get(M.getContext(), llvm::APInt(32, 7479, false));
    args = {wut, zero};
    LHSConsts.push_back(args);

    wut = llvm::ConstantInt::get(M.getContext(), llvm::APInt(32, 45, false));
    args = {wut, zero};
    LHSConsts.push_back(args);

    wut = llvm::ConstantInt::get(M.getContext(), llvm::APInt(32, -1, false));
    args = {wut, zero};
    LHSConsts.push_back(args);
  }

  std::vector<llvm::SmallVector<llvm::Constant *, 2>> LHSConsts;
  std::unordered_set<llvm::Function *> refuted;
};

}  // end of anonymous namespace

char RefuteOpts::ID = 0;
static RegisterPass<RefuteOpts> X("refute", "opt-refute pass",
                             false /* Only looks at CFG */,
                             false /* Analysis Pass */);
